(* ======================================================= *)
(* CarTraC - ProVerif model                                *)
(* Secrecy + reachability + non-repudiation (DY attacker)  *)
(* ======================================================= *)

set traceDisplay = long.
set attacker = active.

(* -------------------- Types -------------------- *)
type skey. (* Signing / long-term private keys *)
type pkey. (* Public keys corresponding to skey *)
type key.  (* Symmetric key (AES-GCM style) *)

(* -------------------- Channels -------------------- *)
free v2v_chan   : channel.          (* Public V2V broadcast channel - DY-controlled *)
free ta_chan    : channel [private].(* Internal TA processing channel, not visible to attacker *)
free v_ta_chan  : channel.          (* Public Vehicleâ€“TA channel for nonce-based freshness *)

(* -------------------- Cryptographic primitives -------------------- *)

(* Asymmetric encryption for other use (not used here but kept) *)
fun pk(skey): pkey.
fun aenc(bitstring, pkey): bitstring.
reduc forall m: bitstring, k: skey; adec(aenc(m, pk(k)), k) = m.

(* Signatures *)
fun sign(bitstring, skey): bitstring.
reduc forall m: bitstring, k: skey; checksign(sign(m, k), pk(k)) = m.
reduc forall m: bitstring, k: skey; getmess(sign(m, k)) = m.

(* Symmetric authenticated encryption (AES-GCM abstracted) *)
fun senc(bitstring, key) : bitstring.
reduc forall m:bitstring, k:key; sdec(senc(m,k), k) = m.

(* -------------------- Long-term keys & constants -------------------- *)

(* Vehicle 1 signing key stored in TPM, not leaked *)
free sk_V1 : skey [private].

(* Trusted Authority symmetric decryption key stored at TA only *)
free K_TA : key [private].

(* Public identifier / pseudonym and crash data for Vehicle 1 *)
free pseudonym_V1 : bitstring [private]. (* pseudonymous vehicle ID *)
free crashData_V1 : bitstring [private]. (* crash-related data, must remain secret *)

(* Optional tag for the nonce request *)
free collision_nonce_req_tag : bitstring.

(* Table of nonces issued by TA (to prevent accepting the same nonce twice) *)
table nonce_table(bitstring).

(* -------------------- Events -------------------- *)

(* Existing events *)
event crash_detected(bitstring, bitstring).  (* (pseudonym, data) *)
event ta_received(bitstring, bitstring).     (* (pseudonym, data) *)
event success.                               (* simple reachability marker *)

(* New events for non-repudiation reasoning *)
event v1_signs(bitstring).   (* Vehicle 1 signs message-with-nonce *)
event ta_accepts(bitstring). (* TA accepts a signature as valid for message-with-nonce *)

(* Optional events for nonce tracking *)
event ta_issues_nonce(bitstring).           (* TA generates a fresh nonce *)
event ta_sees_nonce_in_msg(bitstring).      (* TA sees a nonce in a received message *)

(* -------------------- Vehicle process -------------------- *)

let Vehicle =
    (* Crash detection event *)
    event crash_detected(pseudonym_V1, crashData_V1);

    (* -------- Mitigation of T2.2 (M5): nonce-based freshness with TA -------- *)
    (* Step 1: Vehicle requests a nonce from the TA *)
    out(v_ta_chan, (collision_nonce_req_tag, pseudonym_V1));   (* V -> TA: "collision, I need a nonce" *)

    (* Step 2: Vehicle receives a unique nonce from TA *)
    in(v_ta_chan, n:bitstring);                                (* TA -> V: nonce *)

    (* Build the secure message as before *)
    let payload: bitstring = (pseudonym_V1, crashData_V1) in
    let securemessage: bitstring = senc(payload, K_TA) in

    (* Attach nonce to the secure message *)
    let msg_with_nonce: bitstring = (n, securemessage) in

    (* Non-repudiation: record that V1 signs this specific (nonce, securemessage) pair *)
    event v1_signs(msg_with_nonce);
    let sm: bitstring = sign(msg_with_nonce, sk_V1) in

    (* Final message flows over the V2V channel (can be relayed cooperatively) *)
    out(v2v_chan, sm).

(* -------------------- Cooperative relay process -------------------- *)

let Relay =
    in(v2v_chan, msg:bitstring);
    out(v2v_chan, msg).

(* -------------------- Trusted Authority process -------------------- *)

let TA =
    (* --- Phase 1: nonce service --- *)
    in(v_ta_chan, req:bitstring);                (* Expect something like (collision_nonce_req_tag, pseudonym_V1) *)
    new n:bitstring;                             (* Generate fresh nonce *)
    event ta_issues_nonce(n);
    insert nonce_table(n);                       (* Record that this nonce has been issued *)
    out(v_ta_chan, n);                           (* TA -> V: nonce *)

    (* --- Phase 2: receive final signed message containing the nonce and secure message --- *)
    in(v2v_chan, sm:bitstring);                  (* Receive signed message over V2V *)
    let msg_with_nonce:bitstring = checksign(sm, pk(sk_V1)) in
    event ta_sees_nonce_in_msg(getmess(sm));

    (* Split (nonce, securemessage) *)
    let (n2:bitstring, securemessage:bitstring) = msg_with_nonce in

    (* Check that the nonce was issued by TA (simple freshness/tracking model) *)
    get nonce_table(n2) in                       (* Only succeeds if nonce n2 was issued by TA *)
    event ta_accepts(msg_with_nonce);

    (* Decrypt securemessage and recover (pseudonym, crashData) *)
    let (p:bitstring, d:bitstring) = sdec(securemessage, K_TA) in
    event ta_received(p, d);
    event success;
    out(ta_chan, (p, d)).

(* -------------------- Security queries -------------------- *)

(* Secrecy of crash data *)
query attacker(crashData_V1).

(* Secrecy of Vehicle 1's signing key *)
query attacker(sk_V1).

(* Reachability *)
query event(success).

(* Authenticity crash_detected -> ta_received *)
query p: bitstring, d: bitstring;
      event(ta_received(p, d)) ==> event(crash_detected(p, d)).

(* Non-repudiation of origin (non-injective) *)
query c: bitstring;
      event(ta_accepts(c)) ==> event(v1_signs(c)).

(* Stronger, injective version *)
query c: bitstring;
      inj-event(ta_accepts(c)) ==> event(v1_signs(c)).

(* -------------------- Main process -------------------- *)
process
     Vehicle
  |  TA
  |  Relay
  |  Relay
